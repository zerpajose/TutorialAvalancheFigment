"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @packageDocumentation
 * @module AvalancheCore
 */
const axios_1 = __importDefault(require("axios"));
const apibase_1 = require("./common/apibase");
const helperfunctions_1 = require("./utils/helperfunctions");
/**
 * AvalancheCore is middleware for interacting with Avalanche node RPC APIs.
 *
 * Example usage:
 * ```js
 * let avalanche = new AvalancheCore("127.0.0.1", 9650, "https");
 * ```
 *
 */
class AvalancheCore {
    /**
     * Creates a new Avalanche instance. Sets the address and port of the main Avalanche Client.
     *
     * @param ip The hostname to resolve to reach the Avalanche Client APIs
     * @param port The port to resolve to reach the Avalanche Client APIs
     * @param protocol The protocol string to use before a "://" in a request, ex: "http", "https", "git", "ws", etc ...
     */
    constructor(ip, port, protocol = 'http') {
        this.networkID = 0;
        this.hrp = '';
        this.auth = undefined;
        this.headers = {};
        this.apis = {};
        /**
           * Sets the address and port of the main Avalanche Client.
           *
           * @param ip The hostname to resolve to reach the Avalanche Client RPC APIs
           * @param port The port to resolve to reach the Avalanche Client RPC APIs
           * @param protocol The protocol string to use before a "://" in a request,
           * ex: "http", "https", "git", "ws", etc ...
           */
        this.setAddress = (ip, port, protocol = 'http') => {
            this.ip = ip;
            this.port = port;
            this.protocol = protocol;
            let url = `${protocol}://${ip}`;
            if (port != undefined && typeof port === 'number' && port >= 0) {
                url = `${url}:${port}`;
            }
            this.url = url;
        };
        /**
           * Returns the protocol such as "http", "https", "git", "ws", etc.
           */
        this.getProtocol = () => this.protocol;
        /**
           * Returns the IP for the Avalanche node.
           */
        this.getIP = () => this.ip;
        /**
           * Returns the port for the Avalanche node.
           */
        this.getPort = () => this.port;
        /**
           * Returns the URL of the Avalanche node (ip + port);
           */
        this.getURL = () => this.url;
        /**
         * Returns the custom headers
         */
        this.getHeaders = () => this.headers;
        /**
           * Returns the networkID;
           */
        this.getNetworkID = () => this.networkID;
        /**
           * Sets the networkID
           */
        this.setNetworkID = (netid) => {
            this.networkID = netid;
            this.hrp = helperfunctions_1.getPreferredHRP(this.networkID);
        };
        /**
         * Returns the Human-Readable-Part of the network associated with this key.
         *
         * @returns The [[KeyPair]]'s Human-Readable-Part of the network's Bech32 addressing scheme
         */
        this.getHRP = () => this.hrp;
        /**
         * Sets the the Human-Readable-Part of the network associated with this key.
         *
         * @param hrp String for the Human-Readable-Part of Bech32 addresses
         */
        this.setHRP = (hrp) => {
            this.hrp = hrp;
        };
        /**
         * Adds a new custom header to be included with all requests.
         *
         * @param key Header name
         * @param value Header value
         */
        this.setHeader = (key, value) => {
            this.headers[key] = value;
        };
        /**
         * Sets the temporary auth token used for communicating with the node.
         *
         * @param auth A temporary token provided by the node enabling access to the endpoints on the node.
         */
        this.setAuthToken = (auth) => {
            this.auth = auth;
        };
        this._setHeaders = (headers) => {
            if (typeof this.headers === "object") {
                for (const [key, value] of Object.entries(this.headers)) {
                    headers[key] = value;
                }
            }
            if (typeof this.auth === "string") {
                headers["Authorization"] = "Bearer " + this.auth;
            }
            return headers;
        };
        /**
         * Adds an API to the middleware. The API resolves to a registered blockchain's RPC.
         *
         * In TypeScript:
         * ```js
         * avalanche.addAPI<MyVMClass>("mychain", MyVMClass, "/ext/bc/mychain");
         * ```
         *
         * In Javascript:
         * ```js
         * avalanche.addAPI("mychain", MyVMClass, "/ext/bc/mychain");
         * ```
         *
         * @typeparam GA Class of the API being added
         * @param apiName A label for referencing the API in the future
         * @param ConstructorFN A reference to the class which instantiates the API
         * @param baseurl Path to resolve to reach the API
         *
         */
        this.addAPI = (apiName, ConstructorFN, baseurl = undefined, ...args) => {
            if (typeof baseurl === 'undefined') {
                this.apis[apiName] = new ConstructorFN(this, undefined, ...args);
            }
            else {
                this.apis[apiName] = new ConstructorFN(this, baseurl, ...args);
            }
        };
        /**
         * Retrieves a reference to an API by its apiName label.
         *
         * @param apiName Name of the API to return
         */
        this.api = (apiName) => this.apis[apiName];
        /**
         * @ignore
         */
        this._request = (xhrmethod, baseurl, getdata, postdata, headers = {}, axiosConfig = undefined) => __awaiter(this, void 0, void 0, function* () {
            let config;
            if (axiosConfig) {
                config = axiosConfig;
            }
            else {
                config = {
                    baseURL: `${this.protocol}://${this.ip}:${this.port}`,
                    responseType: 'text',
                };
            }
            config.url = baseurl;
            config.method = xhrmethod;
            config.headers = headers;
            config.data = postdata;
            config.params = getdata;
            return axios_1.default.request(config).then((resp) => {
                // purging all that is axios
                const xhrdata = new apibase_1.RequestResponseData();
                xhrdata.data = resp.data;
                xhrdata.headers = resp.headers;
                xhrdata.request = resp.request;
                xhrdata.status = resp.status;
                xhrdata.statusText = resp.statusText;
                return xhrdata;
            });
        });
        /**
         * Makes a GET call to an API.
         *
         * @param baseurl Path to the api
         * @param getdata Object containing the key value pairs sent in GET
         * @param parameters Object containing the parameters of the API call
         * @param headers An array HTTP Request Headers
         * @param axiosConfig Configuration for the axios javascript library that will be the
         * foundation for the rest of the parameters
         *
         * @returns A promise for [[RequestResponseData]]
         */
        this.get = (baseurl, getdata, headers = {}, axiosConfig = undefined) => this._request('GET', baseurl, getdata, {}, this._setHeaders(headers), axiosConfig);
        /**
         * Makes a DELETE call to an API.
         *
         * @param baseurl Path to the API
         * @param getdata Object containing the key value pairs sent in DELETE
         * @param parameters Object containing the parameters of the API call
         * @param headers An array HTTP Request Headers
         * @param axiosConfig Configuration for the axios javascript library that will be the
         * foundation for the rest of the parameters
         *
         * @returns A promise for [[RequestResponseData]]
         */
        this.delete = (baseurl, getdata, headers = {}, axiosConfig = undefined) => this._request('DELETE', baseurl, getdata, {}, this._setHeaders(headers), axiosConfig);
        /**
         * Makes a POST call to an API.
         *
         * @param baseurl Path to the API
         * @param getdata Object containing the key value pairs sent in POST
         * @param postdata Object containing the key value pairs sent in POST
         * @param parameters Object containing the parameters of the API call
         * @param headers An array HTTP Request Headers
         * @param axiosConfig Configuration for the axios javascript library that will be the
         * foundation for the rest of the parameters
         *
         * @returns A promise for [[RequestResponseData]]
         */
        this.post = (baseurl, getdata, postdata, headers = {}, axiosConfig = undefined) => this._request('POST', baseurl, getdata, postdata, this._setHeaders(headers), axiosConfig);
        /**
         * Makes a PUT call to an API.
         *
         * @param baseurl Path to the baseurl
         * @param getdata Object containing the key value pairs sent in PUT
         * @param postdata Object containing the key value pairs sent in PUT
         * @param parameters Object containing the parameters of the API call
         * @param headers An array HTTP Request Headers
         * @param axiosConfig Configuration for the axios javascript library that will be the
         * foundation for the rest of the parameters
         *
         * @returns A promise for [[RequestResponseData]]
         */
        this.put = (baseurl, getdata, postdata, headers = {}, axiosConfig = undefined) => this._request('PUT', baseurl, getdata, postdata, this._setHeaders(headers), axiosConfig);
        /**
         * Makes a PATCH call to an API.
         *
         * @param baseurl Path to the baseurl
         * @param getdata Object containing the key value pairs sent in PATCH
         * @param postdata Object containing the key value pairs sent in PATCH
         * @param parameters Object containing the parameters of the API call
         * @param headers An array HTTP Request Headers
         * @param axiosConfig Configuration for the axios javascript library that will be the
         * foundation for the rest of the parameters
         *
         * @returns A promise for [[RequestResponseData]]
         */
        this.patch = (baseurl, getdata, postdata, headers = {}, axiosConfig = undefined) => this._request('PATCH', baseurl, getdata, postdata, this._setHeaders(headers), axiosConfig);
        this.setAddress(ip, port, protocol);
    }
}
exports.default = AvalancheCore;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZhbGFuY2hlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2F2YWxhbmNoZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7R0FHRztBQUNILGtEQUF5RTtBQUN6RSw4Q0FBZ0U7QUFDaEUsNkRBQTBEO0FBRTFEOzs7Ozs7OztHQVFHO0FBQ0gsTUFBcUIsYUFBYTtJQTZUaEM7Ozs7OztPQU1HO0lBQ0gsWUFBWSxFQUFTLEVBQUUsSUFBVyxFQUFFLFdBQWtCLE1BQU07UUFuVWxELGNBQVMsR0FBVSxDQUFDLENBQUM7UUFFckIsUUFBRyxHQUFVLEVBQUUsQ0FBQztRQVVoQixTQUFJLEdBQVUsU0FBUyxDQUFDO1FBRXhCLFlBQU8sR0FBMkIsRUFBRSxDQUFDO1FBRXJDLFNBQUksR0FBNEIsRUFBRSxDQUFDO1FBRTdDOzs7Ozs7O2FBT0s7UUFDTCxlQUFVLEdBQUcsQ0FBQyxFQUFTLEVBQUUsSUFBVyxFQUFFLFdBQWtCLE1BQU0sRUFBRSxFQUFFO1lBQ2hFLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7WUFDakIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7WUFDekIsSUFBSSxHQUFHLEdBQVksR0FBRyxRQUFRLE1BQU0sRUFBRSxFQUFFLENBQUM7WUFDekMsSUFBRyxJQUFJLElBQUksU0FBUyxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsSUFBSSxJQUFJLElBQUksQ0FBQyxFQUFFO2dCQUM3RCxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7YUFDeEI7WUFDRCxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNqQixDQUFDLENBQUM7UUFFRjs7YUFFSztRQUNMLGdCQUFXLEdBQUcsR0FBVSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUV6Qzs7YUFFSztRQUNMLFVBQUss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RUFDbkIsY0FBaUMsU0FBUyxFQUNiLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFDckQsT0FBTyxFQUNQLE9BQU8sRUFDUCxRQUFRLEVBQ1IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsRUFDekIsV0FBVyxDQUFDLENBQUM7UUFVYixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdEMsQ0FBQztDQUNGO0FBdlVELGdDQXVVQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIEF2YWxhbmNoZUNvcmVcbiAqL1xuaW1wb3J0IGF4aW9zLCB7IEF4aW9zUmVxdWVzdENvbmZpZywgQXhpb3NSZXNwb25zZSwgTWV0aG9kIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgQVBJQmFzZSwgUmVxdWVzdFJlc3BvbnNlRGF0YSB9IGZyb20gJy4vY29tbW9uL2FwaWJhc2UnO1xuaW1wb3J0IHsgZ2V0UHJlZmVycmVkSFJQIH0gZnJvbSAnLi91dGlscy9oZWxwZXJmdW5jdGlvbnMnO1xuXG4vKipcbiAqIEF2YWxhbmNoZUNvcmUgaXMgbWlkZGxld2FyZSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBBdmFsYW5jaGUgbm9kZSBSUEMgQVBJcy5cbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICogYGBganNcbiAqIGxldCBhdmFsYW5jaGUgPSBuZXcgQXZhbGFuY2hlQ29yZShcIjEyNy4wLjAuMVwiLCA5NjUwLCBcImh0dHBzXCIpO1xuICogYGBgXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdmFsYW5jaGVDb3JlIHtcbiAgcHJvdGVjdGVkIG5ldHdvcmtJRDpudW1iZXIgPSAwO1xuXG4gIHByb3RlY3RlZCBocnA6c3RyaW5nID0gJyc7XG5cbiAgcHJvdGVjdGVkIHByb3RvY29sOnN0cmluZztcblxuICBwcm90ZWN0ZWQgaXA6c3RyaW5nO1xuXG4gIHByb3RlY3RlZCBwb3J0Om51bWJlcjtcblxuICBwcm90ZWN0ZWQgdXJsOnN0cmluZztcblxuICBwcm90ZWN0ZWQgYXV0aDpzdHJpbmcgPSB1bmRlZmluZWQ7XG5cbiAgcHJvdGVjdGVkIGhlYWRlcnM6eyBbazogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcblxuICBwcm90ZWN0ZWQgYXBpczp7IFtrOiBzdHJpbmddOiBBUElCYXNlIH0gPSB7fTtcblxuICAvKipcbiAgICAgKiBTZXRzIHRoZSBhZGRyZXNzIGFuZCBwb3J0IG9mIHRoZSBtYWluIEF2YWxhbmNoZSBDbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXAgVGhlIGhvc3RuYW1lIHRvIHJlc29sdmUgdG8gcmVhY2ggdGhlIEF2YWxhbmNoZSBDbGllbnQgUlBDIEFQSXNcbiAgICAgKiBAcGFyYW0gcG9ydCBUaGUgcG9ydCB0byByZXNvbHZlIHRvIHJlYWNoIHRoZSBBdmFsYW5jaGUgQ2xpZW50IFJQQyBBUElzXG4gICAgICogQHBhcmFtIHByb3RvY29sIFRoZSBwcm90b2NvbCBzdHJpbmcgdG8gdXNlIGJlZm9yZSBhIFwiOi8vXCIgaW4gYSByZXF1ZXN0LFxuICAgICAqIGV4OiBcImh0dHBcIiwgXCJodHRwc1wiLCBcImdpdFwiLCBcIndzXCIsIGV0YyAuLi5cbiAgICAgKi9cbiAgc2V0QWRkcmVzcyA9IChpcDpzdHJpbmcsIHBvcnQ6bnVtYmVyLCBwcm90b2NvbDpzdHJpbmcgPSAnaHR0cCcpID0+IHtcbiAgICB0aGlzLmlwID0gaXA7XG4gICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICB0aGlzLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgbGV0IHVybCA6IHN0cmluZyA9IGAke3Byb3RvY29sfTovLyR7aXB9YDtcbiAgICBpZihwb3J0ICE9IHVuZGVmaW5lZCAmJiB0eXBlb2YgcG9ydCA9PT0gJ251bWJlcicgJiYgcG9ydCA+PSAwKSB7XG4gICAgICB1cmwgPSBgJHt1cmx9OiR7cG9ydH1gO1xuICAgIH1cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm90b2NvbCBzdWNoIGFzIFwiaHR0cFwiLCBcImh0dHBzXCIsIFwiZ2l0XCIsIFwid3NcIiwgZXRjLlxuICAgICAqL1xuICBnZXRQcm90b2NvbCA9ICgpOnN0cmluZyA9PiB0aGlzLnByb3RvY29sO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElQIGZvciB0aGUgQXZhbGFuY2hlIG5vZGUuXG4gICAgICovXG4gIGdldElQID0gKCk6c3RyaW5nID0+IHRoaXMuaXA7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9ydCBmb3IgdGhlIEF2YWxhbmNoZSBub2RlLlxuICAgICAqL1xuICBnZXRQb3J0ID0gKCk6bnVtYmVyID0+IHRoaXMucG9ydDtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVUkwgb2YgdGhlIEF2YWxhbmNoZSBub2RlIChpcCArIHBvcnQpO1xuICAgICAqL1xuICBnZXRVUkwgPSAoKTpzdHJpbmcgPT4gdGhpcy51cmw7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1c3RvbSBoZWFkZXJzXG4gICAqL1xuICBnZXRIZWFkZXJzID0gKCk6b2JqZWN0ID0+IHRoaXMuaGVhZGVycztcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXR3b3JrSUQ7XG4gICAgICovXG4gIGdldE5ldHdvcmtJRCA9ICgpOm51bWJlciA9PiB0aGlzLm5ldHdvcmtJRDtcblxuICAvKipcbiAgICAgKiBTZXRzIHRoZSBuZXR3b3JrSURcbiAgICAgKi9cbiAgc2V0TmV0d29ya0lEID0gKG5ldGlkOm51bWJlcikgPT4ge1xuICAgIHRoaXMubmV0d29ya0lEID0gbmV0aWQ7XG4gICAgdGhpcy5ocnAgPSBnZXRQcmVmZXJyZWRIUlAodGhpcy5uZXR3b3JrSUQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBIdW1hbi1SZWFkYWJsZS1QYXJ0IG9mIHRoZSBuZXR3b3JrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleS5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIFtbS2V5UGFpcl1dJ3MgSHVtYW4tUmVhZGFibGUtUGFydCBvZiB0aGUgbmV0d29yaydzIEJlY2gzMiBhZGRyZXNzaW5nIHNjaGVtZVxuICAgKi9cbiAgZ2V0SFJQID0gKCk6c3RyaW5nID0+IHRoaXMuaHJwO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aGUgSHVtYW4tUmVhZGFibGUtUGFydCBvZiB0aGUgbmV0d29yayBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBocnAgU3RyaW5nIGZvciB0aGUgSHVtYW4tUmVhZGFibGUtUGFydCBvZiBCZWNoMzIgYWRkcmVzc2VzXG4gICAqL1xuICBzZXRIUlAgPSAoaHJwOnN0cmluZyk6dm9pZCA9PiB7XG4gICAgdGhpcy5ocnAgPSBocnA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgY3VzdG9tIGhlYWRlciB0byBiZSBpbmNsdWRlZCB3aXRoIGFsbCByZXF1ZXN0cy5cbiAgICpcbiAgICogQHBhcmFtIGtleSBIZWFkZXIgbmFtZVxuICAgKiBAcGFyYW0gdmFsdWUgSGVhZGVyIHZhbHVlXG4gICAqL1xuICBzZXRIZWFkZXIgPSAoa2V5OnN0cmluZyx2YWx1ZTpzdHJpbmcpOnZvaWQgPT4ge1xuICAgIHRoaXMuaGVhZGVyc1trZXldID0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZW1wb3JhcnkgYXV0aCB0b2tlbiB1c2VkIGZvciBjb21tdW5pY2F0aW5nIHdpdGggdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhdXRoIEEgdGVtcG9yYXJ5IHRva2VuIHByb3ZpZGVkIGJ5IHRoZSBub2RlIGVuYWJsaW5nIGFjY2VzcyB0byB0aGUgZW5kcG9pbnRzIG9uIHRoZSBub2RlLlxuICAgKi9cbiAgc2V0QXV0aFRva2VuID0gKGF1dGg6c3RyaW5nKTp2b2lkID0+IHtcbiAgICB0aGlzLmF1dGggPSBhdXRoO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zZXRIZWFkZXJzID0gKGhlYWRlcnM6b2JqZWN0KTpvYmplY3QgPT4ge1xuICAgIGlmICh0eXBlb2YgdGhpcy5oZWFkZXJzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmhlYWRlcnMpKSB7XG4gICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHR5cGVvZiB0aGlzLmF1dGggPT09IFwic3RyaW5nXCIpe1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJlYXJlciBcIiArIHRoaXMuYXV0aDtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBBUEkgdG8gdGhlIG1pZGRsZXdhcmUuIFRoZSBBUEkgcmVzb2x2ZXMgdG8gYSByZWdpc3RlcmVkIGJsb2NrY2hhaW4ncyBSUEMuXG4gICAqXG4gICAqIEluIFR5cGVTY3JpcHQ6XG4gICAqIGBgYGpzXG4gICAqIGF2YWxhbmNoZS5hZGRBUEk8TXlWTUNsYXNzPihcIm15Y2hhaW5cIiwgTXlWTUNsYXNzLCBcIi9leHQvYmMvbXljaGFpblwiKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEluIEphdmFzY3JpcHQ6XG4gICAqIGBgYGpzXG4gICAqIGF2YWxhbmNoZS5hZGRBUEkoXCJteWNoYWluXCIsIE15Vk1DbGFzcywgXCIvZXh0L2JjL215Y2hhaW5cIik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZXBhcmFtIEdBIENsYXNzIG9mIHRoZSBBUEkgYmVpbmcgYWRkZWRcbiAgICogQHBhcmFtIGFwaU5hbWUgQSBsYWJlbCBmb3IgcmVmZXJlbmNpbmcgdGhlIEFQSSBpbiB0aGUgZnV0dXJlXG4gICAqIEBwYXJhbSBDb25zdHJ1Y3RvckZOIEEgcmVmZXJlbmNlIHRvIHRoZSBjbGFzcyB3aGljaCBpbnN0YW50aWF0ZXMgdGhlIEFQSVxuICAgKiBAcGFyYW0gYmFzZXVybCBQYXRoIHRvIHJlc29sdmUgdG8gcmVhY2ggdGhlIEFQSVxuICAgKlxuICAgKi9cbiAgYWRkQVBJID0gPEdBIGV4dGVuZHMgQVBJQmFzZT4oYXBpTmFtZTpzdHJpbmcsXG4gICAgQ29uc3RydWN0b3JGTjogbmV3KGF2YXg6QXZhbGFuY2hlQ29yZSwgYmFzZXVybD86c3RyaW5nLCAuLi5hcmdzOkFycmF5PGFueT4pID0+IEdBLFxuICAgIGJhc2V1cmw6c3RyaW5nID0gdW5kZWZpbmVkLFxuICAgIC4uLmFyZ3M6QXJyYXk8YW55PikgPT4ge1xuICAgIGlmICh0eXBlb2YgYmFzZXVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuYXBpc1thcGlOYW1lXSA9IG5ldyBDb25zdHJ1Y3RvckZOKHRoaXMsIHVuZGVmaW5lZCwgLi4uYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBpc1thcGlOYW1lXSA9IG5ldyBDb25zdHJ1Y3RvckZOKHRoaXMsIGJhc2V1cmwsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgcmVmZXJlbmNlIHRvIGFuIEFQSSBieSBpdHMgYXBpTmFtZSBsYWJlbC5cbiAgICpcbiAgICogQHBhcmFtIGFwaU5hbWUgTmFtZSBvZiB0aGUgQVBJIHRvIHJldHVyblxuICAgKi9cbiAgYXBpID0gPEdBIGV4dGVuZHMgQVBJQmFzZT4oYXBpTmFtZTpzdHJpbmcpOiBHQSA9PiB0aGlzLmFwaXNbYXBpTmFtZV0gYXMgR0E7XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHByb3RlY3RlZCBfcmVxdWVzdCA9IGFzeW5jICh4aHJtZXRob2Q6TWV0aG9kLFxuICAgIGJhc2V1cmw6c3RyaW5nLFxuICAgIGdldGRhdGE6b2JqZWN0LFxuICAgIHBvc3RkYXRhOnN0cmluZyB8IG9iamVjdCB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3LFxuICAgIGhlYWRlcnM6b2JqZWN0ID0ge30sXG4gICAgYXhpb3NDb25maWc6QXhpb3NSZXF1ZXN0Q29uZmlnID0gdW5kZWZpbmVkKTogUHJvbWlzZTxSZXF1ZXN0UmVzcG9uc2VEYXRhPiA9PiB7XG4gICAgbGV0IGNvbmZpZzpBeGlvc1JlcXVlc3RDb25maWc7XG4gICAgaWYgKGF4aW9zQ29uZmlnKSB7XG4gICAgICBjb25maWcgPSBheGlvc0NvbmZpZztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnID0ge1xuICAgICAgICBiYXNlVVJMOiBgJHt0aGlzLnByb3RvY29sfTovLyR7dGhpcy5pcH06JHt0aGlzLnBvcnR9YCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25maWcudXJsID0gYmFzZXVybDtcbiAgICBjb25maWcubWV0aG9kID0geGhybWV0aG9kO1xuICAgIGNvbmZpZy5oZWFkZXJzID0gaGVhZGVycztcbiAgICBjb25maWcuZGF0YSA9IHBvc3RkYXRhO1xuICAgIGNvbmZpZy5wYXJhbXMgPSBnZXRkYXRhO1xuICAgIHJldHVybiBheGlvcy5yZXF1ZXN0KGNvbmZpZykudGhlbigocmVzcDpBeGlvc1Jlc3BvbnNlPGFueT4pID0+IHtcbiAgICAgIC8vIHB1cmdpbmcgYWxsIHRoYXQgaXMgYXhpb3NcbiAgICAgIGNvbnN0IHhocmRhdGE6UmVxdWVzdFJlc3BvbnNlRGF0YSA9IG5ldyBSZXF1ZXN0UmVzcG9uc2VEYXRhKCk7XG4gICAgICB4aHJkYXRhLmRhdGEgPSByZXNwLmRhdGE7XG4gICAgICB4aHJkYXRhLmhlYWRlcnMgPSByZXNwLmhlYWRlcnM7XG4gICAgICB4aHJkYXRhLnJlcXVlc3QgPSByZXNwLnJlcXVlc3Q7XG4gICAgICB4aHJkYXRhLnN0YXR1cyA9IHJlc3Auc3RhdHVzO1xuICAgICAgeGhyZGF0YS5zdGF0dXNUZXh0ID0gcmVzcC5zdGF0dXNUZXh0O1xuICAgICAgcmV0dXJuIHhocmRhdGE7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgR0VUIGNhbGwgdG8gYW4gQVBJLlxuICAgKlxuICAgKiBAcGFyYW0gYmFzZXVybCBQYXRoIHRvIHRoZSBhcGlcbiAgICogQHBhcmFtIGdldGRhdGEgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleSB2YWx1ZSBwYWlycyBzZW50IGluIEdFVFxuICAgKiBAcGFyYW0gcGFyYW1ldGVycyBPYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgQVBJIGNhbGxcbiAgICogQHBhcmFtIGhlYWRlcnMgQW4gYXJyYXkgSFRUUCBSZXF1ZXN0IEhlYWRlcnNcbiAgICogQHBhcmFtIGF4aW9zQ29uZmlnIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBheGlvcyBqYXZhc2NyaXB0IGxpYnJhcnkgdGhhdCB3aWxsIGJlIHRoZVxuICAgKiBmb3VuZGF0aW9uIGZvciB0aGUgcmVzdCBvZiB0aGUgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgZm9yIFtbUmVxdWVzdFJlc3BvbnNlRGF0YV1dXG4gICAqL1xuICBnZXQgPSAoYmFzZXVybDpzdHJpbmcsXG4gICAgZ2V0ZGF0YTpvYmplY3QsXG4gICAgaGVhZGVyczpvYmplY3QgPSB7fSxcbiAgICBheGlvc0NvbmZpZzpBeGlvc1JlcXVlc3RDb25maWcgPSB1bmRlZmluZWQpXG4gIDogUHJvbWlzZTxSZXF1ZXN0UmVzcG9uc2VEYXRhPiA9PiAgdGhpcy5fcmVxdWVzdCgnR0VUJyxcbiAgICAgIGJhc2V1cmwsXG4gICAgICBnZXRkYXRhLFxuICAgICAge30sXG4gICAgICB0aGlzLl9zZXRIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgYXhpb3NDb25maWcpO1xuXG4gIC8qKlxuICAgKiBNYWtlcyBhIERFTEVURSBjYWxsIHRvIGFuIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIGJhc2V1cmwgUGF0aCB0byB0aGUgQVBJXG4gICAqIEBwYXJhbSBnZXRkYXRhIE9iamVjdCBjb250YWluaW5nIHRoZSBrZXkgdmFsdWUgcGFpcnMgc2VudCBpbiBERUxFVEVcbiAgICogQHBhcmFtIHBhcmFtZXRlcnMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIEFQSSBjYWxsXG4gICAqIEBwYXJhbSBoZWFkZXJzIEFuIGFycmF5IEhUVFAgUmVxdWVzdCBIZWFkZXJzXG4gICAqIEBwYXJhbSBheGlvc0NvbmZpZyBDb25maWd1cmF0aW9uIGZvciB0aGUgYXhpb3MgamF2YXNjcmlwdCBsaWJyYXJ5IHRoYXQgd2lsbCBiZSB0aGVcbiAgICogZm91bmRhdGlvbiBmb3IgdGhlIHJlc3Qgb2YgdGhlIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIGZvciBbW1JlcXVlc3RSZXNwb25zZURhdGFdXVxuICAgKi9cbiAgZGVsZXRlID0gKGJhc2V1cmw6c3RyaW5nLFxuICAgIGdldGRhdGE6b2JqZWN0LFxuICAgIGhlYWRlcnM6b2JqZWN0ID0ge30sXG4gICAgYXhpb3NDb25maWc6QXhpb3NSZXF1ZXN0Q29uZmlnID0gdW5kZWZpbmVkKVxuICA6IFByb21pc2U8UmVxdWVzdFJlc3BvbnNlRGF0YT4gPT4gdGhpcy5fcmVxdWVzdCgnREVMRVRFJyxcbiAgICBiYXNldXJsLFxuICAgIGdldGRhdGEsXG4gICAge30sXG4gICAgdGhpcy5fc2V0SGVhZGVycyhoZWFkZXJzKSxcbiAgICBheGlvc0NvbmZpZyk7XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgUE9TVCBjYWxsIHRvIGFuIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIGJhc2V1cmwgUGF0aCB0byB0aGUgQVBJXG4gICAqIEBwYXJhbSBnZXRkYXRhIE9iamVjdCBjb250YWluaW5nIHRoZSBrZXkgdmFsdWUgcGFpcnMgc2VudCBpbiBQT1NUXG4gICAqIEBwYXJhbSBwb3N0ZGF0YSBPYmplY3QgY29udGFpbmluZyB0aGUga2V5IHZhbHVlIHBhaXJzIHNlbnQgaW4gUE9TVFxuICAgKiBAcGFyYW0gcGFyYW1ldGVycyBPYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgQVBJIGNhbGxcbiAgICogQHBhcmFtIGhlYWRlcnMgQW4gYXJyYXkgSFRUUCBSZXF1ZXN0IEhlYWRlcnNcbiAgICogQHBhcmFtIGF4aW9zQ29uZmlnIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBheGlvcyBqYXZhc2NyaXB0IGxpYnJhcnkgdGhhdCB3aWxsIGJlIHRoZVxuICAgKiBmb3VuZGF0aW9uIGZvciB0aGUgcmVzdCBvZiB0aGUgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgZm9yIFtbUmVxdWVzdFJlc3BvbnNlRGF0YV1dXG4gICAqL1xuICBwb3N0ID0gKGJhc2V1cmw6c3RyaW5nLFxuICAgIGdldGRhdGE6b2JqZWN0LFxuICAgIHBvc3RkYXRhOnN0cmluZyB8IG9iamVjdCB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3LFxuICAgIGhlYWRlcnM6b2JqZWN0ID0ge30sXG4gICAgYXhpb3NDb25maWc6QXhpb3NSZXF1ZXN0Q29uZmlnID0gdW5kZWZpbmVkKVxuICA6IFByb21pc2U8UmVxdWVzdFJlc3BvbnNlRGF0YT4gPT4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsXG4gICAgYmFzZXVybCxcbiAgICBnZXRkYXRhLFxuICAgIHBvc3RkYXRhLFxuICAgIHRoaXMuX3NldEhlYWRlcnMoaGVhZGVycyksXG4gICAgYXhpb3NDb25maWcpO1xuXG4gIC8qKlxuICAgKiBNYWtlcyBhIFBVVCBjYWxsIHRvIGFuIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIGJhc2V1cmwgUGF0aCB0byB0aGUgYmFzZXVybFxuICAgKiBAcGFyYW0gZ2V0ZGF0YSBPYmplY3QgY29udGFpbmluZyB0aGUga2V5IHZhbHVlIHBhaXJzIHNlbnQgaW4gUFVUXG4gICAqIEBwYXJhbSBwb3N0ZGF0YSBPYmplY3QgY29udGFpbmluZyB0aGUga2V5IHZhbHVlIHBhaXJzIHNlbnQgaW4gUFVUXG4gICAqIEBwYXJhbSBwYXJhbWV0ZXJzIE9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBBUEkgY2FsbFxuICAgKiBAcGFyYW0gaGVhZGVycyBBbiBhcnJheSBIVFRQIFJlcXVlc3QgSGVhZGVyc1xuICAgKiBAcGFyYW0gYXhpb3NDb25maWcgQ29uZmlndXJhdGlvbiBmb3IgdGhlIGF4aW9zIGphdmFzY3JpcHQgbGlicmFyeSB0aGF0IHdpbGwgYmUgdGhlXG4gICAqIGZvdW5kYXRpb24gZm9yIHRoZSByZXN0IG9mIHRoZSBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBmb3IgW1tSZXF1ZXN0UmVzcG9uc2VEYXRhXV1cbiAgICovXG4gIHB1dCA9IChiYXNldXJsOnN0cmluZyxcbiAgICBnZXRkYXRhOm9iamVjdCxcbiAgICBwb3N0ZGF0YTpzdHJpbmcgfCBvYmplY3QgfCBBcnJheUJ1ZmZlciB8IEFycmF5QnVmZmVyVmlldyxcbiAgICBoZWFkZXJzOm9iamVjdCA9IHt9LFxuICAgIGF4aW9zQ29uZmlnOkF4aW9zUmVxdWVzdENvbmZpZyA9IHVuZGVmaW5lZClcbiAgOiBQcm9taXNlPFJlcXVlc3RSZXNwb25zZURhdGE+ID0+IHRoaXMuX3JlcXVlc3QoJ1BVVCcsXG4gICAgYmFzZXVybCxcbiAgICBnZXRkYXRhLFxuICAgIHBvc3RkYXRhLFxuICAgIHRoaXMuX3NldEhlYWRlcnMoaGVhZGVycyksXG4gICAgYXhpb3NDb25maWcpO1xuXG4gIC8qKlxuICAgKiBNYWtlcyBhIFBBVENIIGNhbGwgdG8gYW4gQVBJLlxuICAgKlxuICAgKiBAcGFyYW0gYmFzZXVybCBQYXRoIHRvIHRoZSBiYXNldXJsXG4gICAqIEBwYXJhbSBnZXRkYXRhIE9iamVjdCBjb250YWluaW5nIHRoZSBrZXkgdmFsdWUgcGFpcnMgc2VudCBpbiBQQVRDSFxuICAgKiBAcGFyYW0gcG9zdGRhdGEgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleSB2YWx1ZSBwYWlycyBzZW50IGluIFBBVENIXG4gICAqIEBwYXJhbSBwYXJhbWV0ZXJzIE9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBBUEkgY2FsbFxuICAgKiBAcGFyYW0gaGVhZGVycyBBbiBhcnJheSBIVFRQIFJlcXVlc3QgSGVhZGVyc1xuICAgKiBAcGFyYW0gYXhpb3NDb25maWcgQ29uZmlndXJhdGlvbiBmb3IgdGhlIGF4aW9zIGphdmFzY3JpcHQgbGlicmFyeSB0aGF0IHdpbGwgYmUgdGhlXG4gICAqIGZvdW5kYXRpb24gZm9yIHRoZSByZXN0IG9mIHRoZSBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBmb3IgW1tSZXF1ZXN0UmVzcG9uc2VEYXRhXV1cbiAgICovXG4gIHBhdGNoID0gKGJhc2V1cmw6c3RyaW5nLFxuICAgIGdldGRhdGE6b2JqZWN0LFxuICAgIHBvc3RkYXRhOnN0cmluZyB8IG9iamVjdCB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3LFxuICAgIGhlYWRlcnM6b2JqZWN0ID0ge30sXG4gICAgYXhpb3NDb25maWc6QXhpb3NSZXF1ZXN0Q29uZmlnID0gdW5kZWZpbmVkKVxuICA6IFByb21pc2U8UmVxdWVzdFJlc3BvbnNlRGF0YT4gPT4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLFxuICAgIGJhc2V1cmwsXG4gICAgZ2V0ZGF0YSxcbiAgICBwb3N0ZGF0YSxcbiAgICB0aGlzLl9zZXRIZWFkZXJzKGhlYWRlcnMpLFxuICAgIGF4aW9zQ29uZmlnKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBBdmFsYW5jaGUgaW5zdGFuY2UuIFNldHMgdGhlIGFkZHJlc3MgYW5kIHBvcnQgb2YgdGhlIG1haW4gQXZhbGFuY2hlIENsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIGlwIFRoZSBob3N0bmFtZSB0byByZXNvbHZlIHRvIHJlYWNoIHRoZSBBdmFsYW5jaGUgQ2xpZW50IEFQSXNcbiAgICogQHBhcmFtIHBvcnQgVGhlIHBvcnQgdG8gcmVzb2x2ZSB0byByZWFjaCB0aGUgQXZhbGFuY2hlIENsaWVudCBBUElzXG4gICAqIEBwYXJhbSBwcm90b2NvbCBUaGUgcHJvdG9jb2wgc3RyaW5nIHRvIHVzZSBiZWZvcmUgYSBcIjovL1wiIGluIGEgcmVxdWVzdCwgZXg6IFwiaHR0cFwiLCBcImh0dHBzXCIsIFwiZ2l0XCIsIFwid3NcIiwgZXRjIC4uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaXA6c3RyaW5nLCBwb3J0Om51bWJlciwgcHJvdG9jb2w6c3RyaW5nID0gJ2h0dHAnKSB7XG4gICAgdGhpcy5zZXRBZGRyZXNzKGlwLCBwb3J0LCBwcm90b2NvbCk7XG4gIH1cbn1cbiJdfQ==