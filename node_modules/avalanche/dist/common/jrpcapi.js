"use strict";
/**
 * @packageDocumentation
 * @module Common-JRPCAPI
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JRPCAPI = void 0;
const bintools_1 = __importDefault(require("../utils/bintools"));
const apibase_1 = require("./apibase");
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
class JRPCAPI extends apibase_1.APIBase {
    /**
       *
       * @param core Reference to the Avalanche instance using this endpoint
       * @param baseurl Path of the APIs baseurl - ex: "/ext/bc/avm"
       * @param jrpcVersion The jrpc version to use, default "2.0".
       */
    constructor(core, baseurl, jrpcVersion = '2.0') {
        super(core, baseurl);
        this.jrpcVersion = '2.0';
        this.rpcid = 1;
        this.callMethod = (method, params, baseurl, headers) => __awaiter(this, void 0, void 0, function* () {
            const ep = baseurl || this.baseurl;
            const rpc = {};
            rpc.id = this.rpcid;
            rpc.method = method;
            // Set parameters if exists
            if (params) {
                rpc.params = params;
            }
            else if (this.jrpcVersion === '1.0') {
                rpc.params = [];
            }
            if (this.jrpcVersion !== '1.0') {
                rpc.jsonrpc = this.jrpcVersion;
            }
            let headrs = { 'Content-Type': 'application/json;charset=UTF-8' };
            if (headers) {
                headrs = Object.assign(Object.assign({}, headrs), headers);
            }
            let baseURL = `${this.core.getProtocol()}://${this.core.getIP()}`;
            const port = this.core.getPort();
            if (port != undefined && typeof port === 'number' && port >= 0) {
                baseURL = `${baseURL}:${port}`;
            }
            const axConf = {
                baseURL: baseURL,
                responseType: 'json',
            };
            return this.core.post(ep, {}, JSON.stringify(rpc), headrs, axConf)
                .then((resp) => {
                if (resp.status >= 200 && resp.status < 300) {
                    this.rpcid += 1;
                    if (typeof resp.data === 'string') {
                        resp.data = JSON.parse(resp.data);
                    }
                    if (typeof resp.data === 'object' && (resp.data === null || 'error' in resp.data)) {
                        throw new Error("Error");
                    }
                }
                return resp;
            });
        });
        /**
           * Returns the rpcid, a strictly-increasing number, starting from 1, indicating the next
           * request ID that will be sent.
           */
        this.getRPCID = () => this.rpcid;
        this.jrpcVersion = jrpcVersion;
        this.rpcid = 1;
    }
}
exports.JRPCAPI = JRPCAPI;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianJwY2FwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vanJwY2FwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7Ozs7QUFHSCxpRUFBeUM7QUFFekMsdUNBQXlEO0FBRXpEOztHQUVHO0FBQ0gsTUFBTSxRQUFRLEdBQUcsa0JBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUV4QyxNQUFhLE9BQVEsU0FBUSxpQkFBTztJQWdFbEM7Ozs7O1NBS0s7SUFDTCxZQUFZLElBQWtCLEVBQUUsT0FBYyxFQUFFLGNBQXFCLEtBQUs7UUFDeEUsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztRQXRFYixnQkFBVyxHQUFVLEtBQUssQ0FBQztRQUUzQixVQUFLLEdBQUcsQ0FBQyxDQUFDO1FBRXBCLGVBQVUsR0FBRyxDQUNYLE1BQWEsRUFDYixNQUE4QixFQUM5QixPQUFlLEVBQ2YsT0FBZ0IsRUFDZSxFQUFFO1lBQ2pDLE1BQU0sRUFBRSxHQUFHLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQ25DLE1BQU0sR0FBRyxHQUFPLEVBQUUsQ0FBQztZQUNuQixHQUFHLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7WUFDcEIsR0FBRyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7WUFFcEIsMkJBQTJCO1lBQzNCLElBQUksTUFBTSxFQUFFO2dCQUNWLEdBQUcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO2FBQ3JCO2lCQUFNLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxLQUFLLEVBQUU7Z0JBQ3JDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO2FBQ2pCO1lBRUQsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLEtBQUssRUFBRTtnQkFDOUIsR0FBRyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO2FBQ2hDO1lBRUQsSUFBSSxNQUFNLEdBQVUsRUFBRSxjQUFjLEVBQUUsZ0NBQWdDLEVBQUUsQ0FBQztZQUN6RSxJQUFHLE9BQU8sRUFBRTtnQkFDVixNQUFNLG1DQUFPLE1BQU0sR0FBSyxPQUFPLENBQUMsQ0FBQzthQUNsQztZQUVELElBQUksT0FBTyxHQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7WUFDMUUsTUFBTSxJQUFJLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN6QyxJQUFHLElBQUksSUFBSSxTQUFTLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxJQUFJLElBQUksSUFBSSxDQUFDLEVBQUU7Z0JBQzdELE9BQU8sR0FBRyxHQUFHLE9BQU8sSUFBSSxJQUFJLEVBQUUsQ0FBQzthQUNoQztZQUVELE1BQU0sTUFBTSxHQUFzQjtnQkFDaEMsT0FBTyxFQUFFLE9BQU87Z0JBQ2hCLFlBQVksRUFBRSxNQUFNO2FBQ3JCLENBQUM7WUFFRixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDO2lCQUMvRCxJQUFJLENBQUMsQ0FBQyxJQUF3QixFQUFFLEVBQUU7Z0JBQ2pDLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUU7b0JBQzNDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDO29CQUNoQixJQUFJLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7d0JBQ2pDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7cUJBQ25DO29CQUNELElBQUksT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7d0JBQ2pGLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7cUJBQzFCO2lCQUNGO2dCQUNELE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUEsQ0FBQztRQUVGOzs7YUFHSztRQUNMLGFBQVEsR0FBRyxHQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBVWpDLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBQy9CLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLENBQUM7Q0FDRjtBQTNFRCwwQkEyRUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBDb21tb24tSlJQQ0FQSVxuICovXG5cbmltcG9ydCB7IEF4aW9zUmVxdWVzdENvbmZpZyB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCBCaW5Ub29scyBmcm9tICcuLi91dGlscy9iaW50b29scyc7XG5pbXBvcnQgQXZhbGFuY2hlQ29yZSBmcm9tICcuLi9hdmFsYW5jaGUnO1xuaW1wb3J0IHsgQVBJQmFzZSwgUmVxdWVzdFJlc3BvbnNlRGF0YSB9IGZyb20gJy4vYXBpYmFzZSc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBiaW50b29scyA9IEJpblRvb2xzLmdldEluc3RhbmNlKCk7XG5cbmV4cG9ydCBjbGFzcyBKUlBDQVBJIGV4dGVuZHMgQVBJQmFzZSB7XG4gIHByb3RlY3RlZCBqcnBjVmVyc2lvbjpzdHJpbmcgPSAnMi4wJztcblxuICBwcm90ZWN0ZWQgcnBjaWQgPSAxO1xuXG4gIGNhbGxNZXRob2QgPSBhc3luYyAoXG4gICAgbWV0aG9kOnN0cmluZyxcbiAgICBwYXJhbXM/OkFycmF5PG9iamVjdD4gfCBvYmplY3QsXG4gICAgYmFzZXVybD86c3RyaW5nLFxuICAgIGhlYWRlcnM/OiBvYmplY3RcbiAgICApOlByb21pc2U8UmVxdWVzdFJlc3BvbnNlRGF0YT4gPT4ge1xuICAgIGNvbnN0IGVwID0gYmFzZXVybCB8fCB0aGlzLmJhc2V1cmw7XG4gICAgY29uc3QgcnBjOmFueSA9IHt9O1xuICAgIHJwYy5pZCA9IHRoaXMucnBjaWQ7XG4gICAgcnBjLm1ldGhvZCA9IG1ldGhvZDtcblxuICAgIC8vIFNldCBwYXJhbWV0ZXJzIGlmIGV4aXN0c1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIHJwYy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSBlbHNlIGlmICh0aGlzLmpycGNWZXJzaW9uID09PSAnMS4wJykge1xuICAgICAgcnBjLnBhcmFtcyA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmpycGNWZXJzaW9uICE9PSAnMS4wJykge1xuICAgICAgcnBjLmpzb25ycGMgPSB0aGlzLmpycGNWZXJzaW9uO1xuICAgIH1cblxuICAgIGxldCBoZWFkcnM6b2JqZWN0ID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCcgfTtcbiAgICBpZihoZWFkZXJzKSB7XG4gICAgICBoZWFkcnMgPSB7Li4uaGVhZHJzLCAuLi5oZWFkZXJzfTtcbiAgICB9XG5cbiAgICBsZXQgYmFzZVVSTDogc3RyaW5nID0gYCR7dGhpcy5jb3JlLmdldFByb3RvY29sKCl9Oi8vJHt0aGlzLmNvcmUuZ2V0SVAoKX1gO1xuICAgIGNvbnN0IHBvcnQ6IG51bWJlciA9IHRoaXMuY29yZS5nZXRQb3J0KCk7XG4gICAgaWYocG9ydCAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIHBvcnQgPT09ICdudW1iZXInICYmIHBvcnQgPj0gMCkge1xuICAgICAgYmFzZVVSTCA9IGAke2Jhc2VVUkx9OiR7cG9ydH1gO1xuICAgIH1cblxuICAgIGNvbnN0IGF4Q29uZjpBeGlvc1JlcXVlc3RDb25maWcgPSB7XG4gICAgICBiYXNlVVJMOiBiYXNlVVJMLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmNvcmUucG9zdChlcCwge30sIEpTT04uc3RyaW5naWZ5KHJwYyksIGhlYWRycywgYXhDb25mKVxuICAgICAgLnRoZW4oKHJlc3A6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4ge1xuICAgICAgICBpZiAocmVzcC5zdGF0dXMgPj0gMjAwICYmIHJlc3Auc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgdGhpcy5ycGNpZCArPSAxO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzcC5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzcC5kYXRhID0gSlNPTi5wYXJzZShyZXNwLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3AuZGF0YSA9PT0gJ29iamVjdCcgJiYgKHJlc3AuZGF0YSA9PT0gbnVsbCB8fCAnZXJyb3InIGluIHJlc3AuZGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJwY2lkLCBhIHN0cmljdGx5LWluY3JlYXNpbmcgbnVtYmVyLCBzdGFydGluZyBmcm9tIDEsIGluZGljYXRpbmcgdGhlIG5leHRcbiAgICAgKiByZXF1ZXN0IElEIHRoYXQgd2lsbCBiZSBzZW50LlxuICAgICAqL1xuICBnZXRSUENJRCA9ICgpOm51bWJlciA9PiB0aGlzLnJwY2lkO1xuXG4gIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvcmUgUmVmZXJlbmNlIHRvIHRoZSBBdmFsYW5jaGUgaW5zdGFuY2UgdXNpbmcgdGhpcyBlbmRwb2ludFxuICAgICAqIEBwYXJhbSBiYXNldXJsIFBhdGggb2YgdGhlIEFQSXMgYmFzZXVybCAtIGV4OiBcIi9leHQvYmMvYXZtXCJcbiAgICAgKiBAcGFyYW0ganJwY1ZlcnNpb24gVGhlIGpycGMgdmVyc2lvbiB0byB1c2UsIGRlZmF1bHQgXCIyLjBcIi5cbiAgICAgKi9cbiAgY29uc3RydWN0b3IoY29yZTpBdmFsYW5jaGVDb3JlLCBiYXNldXJsOnN0cmluZywganJwY1ZlcnNpb246c3RyaW5nID0gJzIuMCcpIHtcbiAgICBzdXBlcihjb3JlLCBiYXNldXJsKTtcbiAgICB0aGlzLmpycGNWZXJzaW9uID0ganJwY1ZlcnNpb247XG4gICAgdGhpcy5ycGNpZCA9IDE7XG4gIH1cbn1cblxuXG5cblxuXG4iXX0=